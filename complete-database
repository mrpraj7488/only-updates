-- VidGro Database Backup (Server-Side)
-- Created: 2025-08-10T17:43:54.640Z
-- Type: complete
-- Tables: profiles, videos, transactions, bug_reports, runtime_config, system_settings, admin_logs, video_deletions
-- Database: https://kuibswqfmhhdybttbcoa.supabase.co
-- Connection: postgresql://postgres:[Vidgro@12345]@db.kuibswqfmhhdybttbcoa.supabase.co:5432/postgres

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

-- Begin Transaction
BEGIN;


-- Table structure for profiles
-- Warning: Could not get table structure for profiles
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "profiles" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for profiles
CREATE INDEX IF NOT EXISTS "idx_profiles_email" ON "profiles" ("email");
CREATE INDEX IF NOT EXISTS "idx_profiles_referral_code" ON "profiles" ("referral_code");
CREATE INDEX IF NOT EXISTS "idx_profiles_username" ON "profiles" ("username");
CREATE INDEX IF NOT EXISTS "profiles_email_key" ON "profiles" ("email");
CREATE INDEX IF NOT EXISTS "profiles_referral_code_key" ON "profiles" ("referral_code");
CREATE INDEX IF NOT EXISTS "profiles_username_key" ON "profiles" ("username");

-- Data for profiles
INSERT INTO "profiles" ("id", "email", "username", "coins", "is_vip", "vip_expires_at", "referral_code", "referred_by", "created_at", "updated_at") VALUES ('67fa0f44-7d82-43eb-a7ae-2588b464a8c2', 'bbb@gmail.com', 'bbb', 445, false, NULL, 'nqn/XUsj', NULL, '2025-07-30T15:34:15.193523+00:00', '2025-07-30T16:50:45.185036+00:00');
INSERT INTO "profiles" ("id", "email", "username", "coins", "is_vip", "vip_expires_at", "referral_code", "referred_by", "created_at", "updated_at") VALUES ('ea7d018c-7182-4bdc-817e-47918ad7882b', 'abc@gmail.com', 'abc', 999643, false, NULL, 'f+VBA9oi', NULL, '2025-07-29T10:29:07.484491+00:00', '2025-08-06T15:17:03.604953+00:00');
INSERT INTO "profiles" ("id", "email", "username", "coins", "is_vip", "vip_expires_at", "referral_code", "referred_by", "created_at", "updated_at") VALUES ('1474e9c3-38ce-49e7-a468-27108146aaf3', 'ccc@gmail.com', 'cccc', 2957, false, NULL, 'sFDRl01Y', NULL, '2025-08-09T21:23:11.230615+00:00', '2025-08-09T22:52:27.462175+00:00');
INSERT INTO "profiles" ("id", "email", "username", "coins", "is_vip", "vip_expires_at", "referral_code", "referred_by", "created_at", "updated_at") VALUES ('5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'demo@gmail.com', 'demi', 13761, false, NULL, '8BpIejT9', NULL, '2025-07-29T14:57:51.286542+00:00', '2025-08-10T14:20:41.15197+00:00');

-- Table structure for videos
-- Warning: Could not get table structure for videos
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "videos" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for videos
CREATE INDEX IF NOT EXISTS "idx_videos_coins_earned" ON "videos" ("coins_earned_total");
CREATE INDEX IF NOT EXISTS "idx_videos_completed" ON "videos" ("completed");
CREATE INDEX IF NOT EXISTS "idx_videos_completed_status" ON "videos" ("completed", "status");
CREATE INDEX IF NOT EXISTS "idx_videos_created_at" ON "videos" ("created_at");
CREATE INDEX IF NOT EXISTS "idx_videos_hold_until" ON "videos" ("hold_until");
CREATE INDEX IF NOT EXISTS "idx_videos_repromoted_at" ON "videos" ("repromoted_at");
CREATE INDEX IF NOT EXISTS "idx_videos_status" ON "videos" ("status");
CREATE INDEX IF NOT EXISTS "idx_videos_status_completed" ON "videos" ("status", "completed");
CREATE INDEX IF NOT EXISTS "idx_videos_status_views" ON "videos" ("status", "views_count", "target_views");
CREATE INDEX IF NOT EXISTS "idx_videos_user_completed" ON "videos" ("user_id", "completed");
CREATE INDEX IF NOT EXISTS "idx_videos_user_id" ON "videos" ("user_id");

-- Data for videos
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('24696200-73ed-4d12-8af6-dc2b30f45793', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'cKermfJfQhk', 'I Found New tool which is totally amazing unlimited AI videos for you', 10, 35, 30, 10, 168, 'active', '2025-07-29T10:43:33.942304+00:00', NULL, 300, 28.57, '2025-07-29T10:33:33.942304+00:00', '2025-08-06T15:15:25.94247+00:00', false, 100);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('4c31931f-71ad-43ae-9644-0667d033427e', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', '8ORPJG_eQ3E', 'Google Just Released an AI App Builder (No Code)', 6, 35, 30, 10, 168, 'active', NULL, NULL, 180, 17.14, '2025-08-01T13:49:59.152683+00:00', '2025-08-06T15:15:58.567102+00:00', false, 60);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('332afe1c-06cc-4381-8942-8428e4c38404', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', '8ORPJG_eQ3E', 'Google Just Released an AI App Builder (No Code)', 6, 35, 30, 10, 168, 'active', NULL, NULL, 180, 17.14, '2025-08-01T13:51:21.824862+00:00', '2025-08-06T15:16:31.018346+00:00', false, 60);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('267053e0-fbaa-4116-967d-ea8933dfd01b', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'a7ccv_fMoNA', 'VSCode + RooCode + Gemini CLI: STOP PAYING for CURSOR with this OPENSOURCE & LOCAL Alternative', 6, 35, 30, 10, 168, 'active', '2025-08-02T21:21:14.212337+00:00', NULL, 180, 17.14, '2025-08-02T21:11:14.212337+00:00', '2025-08-09T22:49:54.287182+00:00', false, 60);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('306ce3c6-fc27-4bf9-b75e-113ce8d25cc1', 'ea7d018c-7182-4bdc-817e-47918ad7882b', 'Oc9DiSenaik', 'Who Am I (2014) Movie Explained | Hacking And Darknet Recap In Hindi', 15, 50, 60, 25, 480, 'active', '2025-07-29T10:47:36.166606+00:00', '2025-08-01T14:04:55.080983+00:00', 1620, 30, '2025-07-29T10:37:36.166606+00:00', '2025-08-10T14:19:56.250268+00:00', false, 684);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('09a186f1-c66e-4dc6-9a4e-21f77d5b6544', '1474e9c3-38ce-49e7-a468-27108146aaf3', 'a7ccv_fMoNA', 'VSCode + RooCode + Gemini CLI: STOP PAYING for CURSOR with this OPENSOURCE & LOCAL Alternative', 3, 35, 30, 10, 168, 'active', '2025-08-09T23:02:27.462175+00:00', NULL, 90, 8.57, '2025-08-09T22:52:27.462175+00:00', '2025-08-10T14:20:34.003613+00:00', false, 30);
INSERT INTO "videos" ("id", "user_id", "youtube_url", "title", "views_count", "target_views", "duration_seconds", "coin_reward", "coin_cost", "status", "hold_until", "repromoted_at", "total_watch_time", "completion_rate", "created_at", "updated_at", "completed", "coins_earned_total") VALUES ('674a9287-f7bf-47fd-afa3-b266c6e3a338', 'ea7d018c-7182-4bdc-817e-47918ad7882b', 'AuAszI4gags', 'AI vs Humans: AI को लेकर दुनियाभर की सरकारें झूठ बोल रही हैं? | Kachehri With Shubhankar Mishra', 24, 35, 45, 15, 252, 'active', '2025-07-29T10:45:56.487457+00:00', NULL, 945, 68.57, '2025-07-29T10:35:56.487457+00:00', '2025-08-10T14:20:41.15197+00:00', false, 332);

-- Table structure for transactions
-- Warning: Could not get table structure for transactions
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "transactions" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for transactions
CREATE INDEX IF NOT EXISTS "idx_transactions_created_at" ON "transactions" ("created_at");
CREATE INDEX IF NOT EXISTS "idx_transactions_type" ON "transactions" ("type");
CREATE INDEX IF NOT EXISTS "idx_transactions_user_id" ON "transactions" ("user_id");

-- Data for transactions
INSERT INTO "transactions" ("id", "user_id", "type", "amount", "description", "reference_id", "reference_type", "status", "created_at", "updated_at") VALUES ('b5a76b30-2b93-440e-9cb0-599f54210879', '67fa0f44-7d82-43eb-a7ae-2588b464a8c2', 'purchase', 100, 'Video promotion', NULL, NULL, 'completed', '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');
INSERT INTO "transactions" ("id", "user_id", "type", "amount", "description", "reference_id", "reference_type", "status", "created_at", "updated_at") VALUES ('167ddc5d-26f6-4300-bd75-19a1d398d476', '67fa0f44-7d82-43eb-a7ae-2588b464a8c2', 'earn', 50, 'Video completion reward', NULL, NULL, 'completed', '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');
INSERT INTO "transactions" ("id", "user_id", "type", "amount", "description", "reference_id", "reference_type", "status", "created_at", "updated_at") VALUES ('66d0fc43-fad2-4f47-9ed1-5b49aa7b8ee8', '67fa0f44-7d82-43eb-a7ae-2588b464a8c2', 'bonus', 25, 'Welcome bonus', NULL, NULL, 'completed', '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');

-- Table structure for bug_reports
-- Warning: Could not get table structure for bug_reports
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "bug_reports" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for bug_reports
CREATE INDEX IF NOT EXISTS "bug_reports_bug_id_key" ON "bug_reports" ("bug_id");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_category" ON "bug_reports" ("category");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_created_at" ON "bug_reports" ("created_at");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_priority" ON "bug_reports" ("priority");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_source" ON "bug_reports" ("source");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_status" ON "bug_reports" ("status");
CREATE INDEX IF NOT EXISTS "idx_bug_reports_user_id" ON "bug_reports" ("user_id");

-- Data for bug_reports
INSERT INTO "bug_reports" ("id", "bug_id", "title", "description", "status", "priority", "category", "reported_by", "user_id", "user_email", "assigned_to", "device_info", "app_version", "issue_type", "source", "estimated_response_time", "admin_notes", "resolution_notes", "created_at", "updated_at") VALUES ('d880ac6c-7a88-4c6e-8127-cba3bd96374b', 'bug-sample-1', 'App crashes on startup', 'Application crashes immediately when opened on Android devices', 'new', 'critical', 'Mobile App Technical', 'mobile_user', NULL, NULL, NULL, NULL, NULL, 'technical', 'mobile_app', NULL, NULL, NULL, '2025-08-10T14:28:54.699033+00:00', '2025-08-10T14:28:54.699033+00:00');
INSERT INTO "bug_reports" ("id", "bug_id", "title", "description", "status", "priority", "category", "reported_by", "user_id", "user_email", "assigned_to", "device_info", "app_version", "issue_type", "source", "estimated_response_time", "admin_notes", "resolution_notes", "created_at", "updated_at") VALUES ('97f5c637-3a78-43cd-9512-f878f4892458', 'bug-sample-2', 'Database connection timeout', 'Server experiencing database connection timeouts during peak hours', 'in_progress', 'high', 'System', 'admin_panel', NULL, NULL, NULL, NULL, NULL, 'technical', 'admin_panel', NULL, NULL, NULL, '2025-08-10T14:28:54.699033+00:00', '2025-08-10T14:28:54.699033+00:00');
INSERT INTO "bug_reports" ("id", "bug_id", "title", "description", "status", "priority", "category", "reported_by", "user_id", "user_email", "assigned_to", "device_info", "app_version", "issue_type", "source", "estimated_response_time", "admin_notes", "resolution_notes", "created_at", "updated_at") VALUES ('5c628a51-806c-4619-a6a4-19903330cc67', 'bug-sample-3', 'Video playback issues', 'Videos not loading properly on iOS devices', 'new', 'medium', 'Mobile App Technical', 'mobile_user', NULL, NULL, NULL, NULL, NULL, 'technical', 'mobile_app', NULL, NULL, NULL, '2025-08-10T14:28:54.699033+00:00', '2025-08-10T14:28:54.699033+00:00');

-- Table structure for runtime_config
-- Warning: Could not get table structure for runtime_config
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "runtime_config" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for runtime_config
CREATE INDEX IF NOT EXISTS "runtime_config_key_environment_key" ON "runtime_config" ("key", "environment");

-- Data for runtime_config
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('47e6c24b-9117-4d80-b7b0-58c17746d3ce', 'SUPABASE_URL', 'https://kuibswqfmhhdybttbcoa.supabase.co', true, 'production', 'Supabase project URL', 'supabase', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('388acc62-2673-4064-a780-a8b3c5699c93', 'SUPABASE_ANON_KEY', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt1aWJzd3FmbWhoZHlidHRiY29hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3ODIwNTYsImV4cCI6MjA2OTM1ODA1Nn0.Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8Ej8', true, 'production', 'Supabase anonymous key for client apps', 'supabase', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('335b78f2-19d4-4c3a-8dde-183ea5d109fe', 'ADMOB_APP_ID', 'ca-app-pub-2892152842024866~2841739969', true, 'production', 'AdMob application ID', 'admob', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('08f635e9-bee6-4388-83e3-da88cf563d0d', 'ADMOB_BANNER_ID', 'ca-app-pub-2892152842024866/6180566789', true, 'production', 'AdMob banner ad unit ID', 'admob', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('382dee60-a5d7-4085-a7eb-21ede2fb864d', 'ADMOB_INTERSTITIAL_ID', 'ca-app-pub-2892152842024866/2604283857', true, 'production', 'AdMob interstitial ad unit ID', 'admob', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('325880a3-3203-4b59-a28e-0be60c774aa5', 'ADMOB_REWARDED_ID', 'ca-app-pub-2892152842024866/2049185437', true, 'production', 'AdMob rewarded ad unit ID', 'admob', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('7efb95c6-9450-4bf7-a761-4c585408c1e6', 'FEATURE_ADS_ENABLED', 'true', true, 'production', 'Enable/disable ads in mobile app', 'features', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('d9feca26-77df-4358-a0e9-268c424fc20a', 'FEATURE_COINS_ENABLED', 'true', true, 'production', 'Enable/disable coin system', 'features', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('65571a59-8eb4-488c-afc7-b8348b39e887', 'FEATURE_VIP_ENABLED', 'true', true, 'production', 'Enable/disable VIP features', 'features', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('2587ca0a-f04d-43bd-b962-f9e4edd0c229', 'FEATURE_REFERRALS_ENABLED', 'true', true, 'production', 'Enable/disable referral system', 'features', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('02b5b5f8-0a04-43d7-9c2a-8c638b39daf8', 'APP_MIN_VERSION', '1.0.0', true, 'production', 'Minimum supported app version', 'app', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('b2db1aa7-22d6-44e1-ab3d-539b0ac59f52', 'APP_FORCE_UPDATE', 'false', true, 'production', 'Force app update flag', 'app', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('32d9b2e5-48b7-4b34-8099-65ca94fbb481', 'MAINTENANCE_MODE', 'false', true, 'production', 'Maintenance mode flag', 'app', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('aa4e6c12-1019-47e3-bd61-0afac46c5adb', 'SUPABASE_SERVICE_ROLE_KEY', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt1aWJzd3FmbWhoZHlidHRiY29hIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Mzc4MjA1NiwiZXhwIjoyMDY5MzU4MDU2fQ.hJNaVa025MEen4DM567AO1y0NQxAZO3HWt6nbX6OBKs', false, 'production', 'Supabase service role key (backend only)', 'supabase', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('6d094baa-bdc5-4fb2-8f7d-acfdf09d10a0', 'JWT_SECRET', 'vidgro-jwt-secret-2024', false, 'production', 'JWT signing secret', 'security', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);
INSERT INTO "runtime_config" ("id", "key", "value", "is_public", "environment", "description", "category", "created_at", "updated_at", "created_by", "updated_by") VALUES ('aea97544-ff6f-4df3-8f8c-367f67f7b925', 'API_ENCRYPTION_KEY', 'vidgro-encryption-key-2024', false, 'production', 'API encryption key', 'security', '2025-08-08T12:50:45.686215+00:00', '2025-08-08T12:50:45.686215+00:00', NULL, NULL);

-- Table structure for system_settings
-- Warning: Could not get table structure for system_settings
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "system_settings" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for system_settings
CREATE INDEX IF NOT EXISTS "system_settings_category_key_key" ON "system_settings" ("category", "key");

-- Data for system_settings
INSERT INTO "system_settings" ("id", "category", "key", "value", "description", "is_public", "created_at", "updated_at") VALUES ('576978ae-8ddd-4e2e-b0c5-8301d61e93f5', 'economy', 'coinPrice', '0.01', 'Price per coin in USD', false, '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');
INSERT INTO "system_settings" ("id", "category", "key", "value", "description", "is_public", "created_at", "updated_at") VALUES ('8c465194-00aa-4fd9-84db-543d1e3e6e52', 'economy', 'videoReward', '10', 'Default coin reward for video completion', false, '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');
INSERT INTO "system_settings" ("id", "category", "key", "value", "description", "is_public", "created_at", "updated_at") VALUES ('4eba744f-f8ed-4011-87de-0c8f87b6d7f5', 'economy', 'referralBonus', '50', 'Bonus coins for successful referrals', false, '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');
INSERT INTO "system_settings" ("id", "category", "key", "value", "description", "is_public", "created_at", "updated_at") VALUES ('e7595f1a-db42-4237-b9c7-ff308453bac2', 'economy', 'vipMultiplier', '2.0', 'VIP user coin multiplier', false, '2025-08-10T14:42:47.794713+00:00', '2025-08-10T14:42:47.794713+00:00');

-- Table structure for admin_logs
-- Warning: Could not get table structure for admin_logs
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "admin_logs" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Data for admin_logs
INSERT INTO "admin_logs" ("id", "admin_id", "action", "target_type", "target_id", "old_values", "new_values", "ip_address", "user_agent", "details", "created_at") VALUES ('ae48bdd0-139f-48f4-9da8-fca7a2af42d3', 'system', 'create_admin', 'admin_profile', '9658e918-3d0b-4ab6-b839-ec62e769e497', NULL, [object Object], 'admin_panel', 'admin_panel', [object Object], '2025-08-02T16:30:58.883685+00:00');
INSERT INTO "admin_logs" ("id", "admin_id", "action", "target_type", "target_id", "old_values", "new_values", "ip_address", "user_agent", "details", "created_at") VALUES ('38a10120-fde1-4f54-a000-fcfabead2766', 'system', 'create_admin', 'admin_profile', '170245f1-7600-4eb0-a65b-68ce3937b017', NULL, [object Object], 'admin_panel', 'admin_panel', [object Object], '2025-08-02T16:39:14.567021+00:00');

-- Table structure for video_deletions
-- Warning: Could not get table structure for video_deletions
-- Using basic CREATE TABLE statement
CREATE TABLE IF NOT EXISTS "video_deletions" (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Data for video_deletions
INSERT INTO "video_deletions" ("id", "video_id", "user_id", "video_title", "coin_cost", "refund_amount", "refund_percentage", "deleted_at", "created_at") VALUES ('fb07ba7c-cae4-49e6-8b67-4049ab3c3db6', '18e2efc9-2056-42fd-9f3c-9e980d966dac', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'Google Just Released an AI App Builder (No Code)', 168, 134, 80, '2025-08-01T13:29:55.715428+00:00', '2025-08-01T13:29:55.715428+00:00');
INSERT INTO "video_deletions" ("id", "video_id", "user_id", "video_title", "coin_cost", "refund_amount", "refund_percentage", "deleted_at", "created_at") VALUES ('6aec2245-415e-4bdf-9051-8929d1f9eaab', '8336ac93-520b-48d6-a26f-64eafd4fee0e', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'Google Just Released an AI App Builder (No Code)', 168, 168, 100, '2025-08-01T13:46:04.974176+00:00', '2025-08-01T13:46:04.974176+00:00');
INSERT INTO "video_deletions" ("id", "video_id", "user_id", "video_title", "coin_cost", "refund_amount", "refund_percentage", "deleted_at", "created_at") VALUES ('3a30283c-eb45-40a9-b262-5ba01cb74ac6', '8bbe5c68-f43b-4b69-94b8-02df33c8ccaa', '5d8618ad-f651-4fe4-aabd-d7fdcb980897', 'Google Just Released an AI App Builder (No Code)', 168, 168, 100, '2025-08-01T13:50:42.062243+00:00', '2025-08-01T13:50:42.062243+00:00');

-- Row Level Security (RLS) Policies
-- Enable RLS on all tables
ALTER TABLE "profiles" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "videos" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "transactions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "bug_reports" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "runtime_config" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "system_settings" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "admin_logs" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "video_deletions" ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles
null
null
CREATE POLICY "Users can read own profile" ON "profiles" FOR SELECT USING ((auth.uid() = id));
CREATE POLICY "Users can update own profile" ON "profiles" FOR UPDATE USING ((auth.uid() = id));

-- RLS Policies for videos
CREATE POLICY "Allow authenticated users to update video metrics" ON "videos" FOR UPDATE USING (true);
CREATE POLICY "Users can delete own videos" ON "videos" FOR DELETE USING ((auth.uid() = user_id));
null
CREATE POLICY "Users can read all videos" ON "videos" FOR SELECT USING (true);
CREATE POLICY "Users can update own videos" ON "videos" FOR UPDATE USING ((auth.uid() = user_id));

-- RLS Policies for transactions
CREATE POLICY "Allow all operations on transactions" ON "transactions" FOR ALL USING (true);

-- RLS Policies for runtime_config
CREATE POLICY "Admins can manage runtime config" ON "runtime_config" FOR ALL USING (true);

-- RLS Policies for system_settings
CREATE POLICY "Allow all operations on system_settings" ON "system_settings" FOR ALL USING (true);

-- RLS Policies for video_deletions
null
null
CREATE POLICY "Users can view their own video deletion records" ON "video_deletions" FOR SELECT USING ((auth.uid() = user_id));

-- Database Functions
CREATE OR REPLACE FUNCTION debug_video_watch_execution(p_user_uuid uuid, p_video_uuid uuid, p_watch_duration integer, p_video_fully_watched boolean) RETURNS TABLE(step text, details jsonb) LANGUAGE plpgsql AS '
DECLARE
  v_video_record RECORD;
  v_user_record RECORD;
  v_coins_to_award INTEGER;
  v_new_total_watch_time INTEGER;
  v_new_completion_rate DECIMAL(5,2);
  v_debug_log JSONB := ''{}'';
BEGIN
  -- Enable error logging
  SET log_min_messages TO DEBUG1;
  
  -- Log function entry
  RAISE LOG ''Entering debug_video_watch_execution: user=%, video=%, duration=%, fully_watched=%'', 
    p_user_uuid, p_video_uuid, p_watch_duration, p_video_fully_watched;

  -- Step 1: Validate Video
  BEGIN
    SELECT * INTO v_video_record FROM videos WHERE id = p_video_uuid;
    IF v_video_record IS NULL THEN
      RAISE EXCEPTION ''Video not found: %'', p_video_uuid;
    END IF;
  EXCEPTION WHEN OTHERS THEN
    RAISE LOG ''Video Validation Error: %'', SQLERRM;
    RETURN QUERY 
    SELECT ''Video Validation''::TEXT, 
           jsonb_build_object(
             ''error'', SQLERRM,
             ''sqlstate'', SQLSTATE,
             ''video_uuid'', p_video_uuid
           );
    RETURN;
  END;

  -- Step 2: Validate User
  BEGIN
    SELECT * INTO v_user_record FROM profiles WHERE id = p_user_uuid;
    IF v_user_record IS NULL THEN
      RAISE EXCEPTION ''User not found: %'', p_user_uuid;
    END IF;
  EXCEPTION WHEN OTHERS THEN
    RAISE LOG ''User Validation Error: %'', SQLERRM;
    RETURN QUERY 
    SELECT ''User Validation''::TEXT, 
           jsonb_build_object(
             ''error'', SQLERRM,
             ''sqlstate'', SQLSTATE,
             ''user_uuid'', p_user_uuid
           );
    RETURN;
  END;

  -- Step 3: Coin Calculation
  BEGIN
    v_coins_to_award := CASE 
      WHEN p_watch_duration >= v_video_record.duration_seconds OR p_video_fully_watched 
      THEN v_video_record.coin_reward
      ELSE GREATEST(1, (v_video_record.coin_reward * p_watch_duration / v_video_record.duration_seconds))
    END;
    
    RAISE LOG ''Coins Calculation: coins_to_award=%, watch_duration=%, video_duration=%'', 
      v_coins_to_award, p_watch_duration, v_video_record.duration_seconds;
  EXCEPTION WHEN OTHERS THEN
    RAISE LOG ''Coin Calculation Error: %'', SQLERRM;
    RETURN QUERY 
    SELECT ''Coin Calculation''::TEXT, 
           jsonb_build_object(
             ''error'', SQLERRM,
             ''sqlstate'', SQLSTATE
           );
    RETURN;
  END;

  -- Step 4: Metrics Calculation
  BEGIN
    v_new_total_watch_time := v_video_record.total_watch_time + p_watch_duration;
    v_new_completion_rate := CASE 
      WHEN v_video_record.target_views > 0 THEN 
        LEAST(100.0, ((v_video_record.views_count + 1)::decimal / v_video_record.target_views) * 100)
      ELSE 0.0
    END;
    
    RAISE LOG ''Metrics Calculation: new_total_watch_time=%, new_completion_rate=%'', 
      v_new_total_watch_time, v_new_completion_rate;
  EXCEPTION WHEN OTHERS THEN
    RAISE LOG ''Metrics Calculation Error: %'', SQLERRM;
    RETURN QUERY 
    SELECT ''Metrics Calculation''::TEXT, 
           jsonb_build_object(
             ''error'', SQLERRM,
             ''sqlstate'', SQLSTATE
           );
    RETURN;
  END;

  -- Step 5: Update Video Metrics
  BEGIN
    UPDATE videos 
    SET 
      views_count = views_count + 1,
      total_watch_time = v_new_total_watch_time,
      completion_rate = v_new_completion_rate,
      coins_earned_total = coins_earned_total + v_coins_to_award,
      completed = CASE 
        WHEN (views_count + 1) >= target_views THEN TRUE 
        ELSE FALSE 
      END,
      status = CASE 
        WHEN (views_count + 1) >= target_views THEN ''completed''
        ELSE status
      END,
      updated_at = NOW()
    WHERE id = p_video_uuid
    RETURNING * INTO v_video_record;
    
    RAISE LOG ''Video Update Successful: views_count=%, total_watch_time=%, completion_rate=%'', 
      v_video_record.views_count, v_video_record.total_watch_time, v_video_record.completion_rate;
  EXCEPTION WHEN OTHERS THEN
    RAISE LOG ''Video Update Error: % (SQLSTATE: %)'', SQLERRM, SQLSTATE;
    RETURN QUERY 
    SELECT ''Video Update''::TEXT, 
           jsonb_build_object(
             ''error'', SQLERRM,
             ''sqlstate'', SQLSTATE,
             ''video_uuid'', p_video_uuid
           );
    RETURN;
  END;

  -- Return comprehensive debug information
  RETURN QUERY 
  SELECT ''Debug Summary''::TEXT, 
         jsonb_build_object(
           ''video_id'', v_video_record.id,
           ''views_count_before'', v_video_record.views_count - 1,
           ''views_count_after'', v_video_record.views_count,
           ''total_watch_time_before'', v_video_record.total_watch_time - p_watch_duration,
           ''total_watch_time_after'', v_video_record.total_watch_time,
           ''coins_awarded'', v_coins_to_award,
           ''completion_rate'', v_video_record.completion_rate
         );
END;
';

CREATE OR REPLACE FUNCTION investigate_video_trigger() RETURNS TABLE(trigger_name text, trigger_timing text, trigger_event text, trigger_function text, is_enabled boolean) LANGUAGE plpgsql AS '
BEGIN
  RETURN QUERY 
  SELECT 
    t.trigger_name::TEXT,
    t.action_timing::TEXT,
    t.event_manipulation::TEXT,
    p.proname::TEXT,
    t.trigger_enabled
  FROM 
    information_schema.triggers t
    JOIN pg_trigger pt ON pt.tgname = t.trigger_name
    JOIN pg_proc p ON p.oid = pt.tgfoid
  WHERE 
    t.event_object_table = ''videos'';
END;
';

CREATE OR REPLACE FUNCTION enable_rls_on_all_tables() RETURNS void LANGUAGE plpgsql AS '
DECLARE
    table_record record;
BEGIN
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = ''public''
    LOOP
        EXECUTE ''ALTER TABLE "'' || table_record.tablename || ''" ENABLE ROW LEVEL SECURITY;'';
    END LOOP;
END;
';

CREATE OR REPLACE FUNCTION upsert_runtime_config(config_key text, config_value text, is_public_param boolean, env_name text, description_param text, category_param text, admin_id_param uuid, admin_email_param text, ip_address_param text, user_agent_param text, reason_param text) RETURNS TABLE(success boolean, message text, config_id uuid) LANGUAGE plpgsql AS '
DECLARE
  existing_config runtime_config%ROWTYPE;
  new_config_id uuid;
  audit_action text;
BEGIN
  -- Check if config exists
  SELECT * INTO existing_config
  FROM runtime_config
  WHERE key = config_key AND environment = env_name;

  IF existing_config.id IS NOT NULL THEN
    -- Update existing config
    UPDATE runtime_config
    SET 
      value = config_value,
      is_public = is_public_param,
      description = COALESCE(description_param, description),
      category = COALESCE(category_param, category),
      updated_at = now(),
      updated_by = admin_id_param
    WHERE id = existing_config.id
    RETURNING id INTO new_config_id;
    
    audit_action := ''update'';
    
    -- Log the change
    INSERT INTO config_audit_log (
      config_key, environment, action, old_value, new_value,
      admin_id, admin_email, ip_address, user_agent, reason
    ) VALUES (
      config_key, env_name, audit_action, existing_config.value, config_value,
      admin_id_param, admin_email_param, ip_address_param, user_agent_param, reason_param
    );
  ELSE
    -- Create new config
    INSERT INTO runtime_config (
      key, value, is_public, environment, description, category, created_by, updated_by
    ) VALUES (
      config_key, config_value, is_public_param, env_name, description_param, category_param, admin_id_param, admin_id_param
    ) RETURNING id INTO new_config_id;
    
    audit_action := ''create'';
    
    -- Log the creation
    INSERT INTO config_audit_log (
      config_key, environment, action, new_value,
      admin_id, admin_email, ip_address, user_agent, reason
    ) VALUES (
      config_key, env_name, audit_action, config_value,
      admin_id_param, admin_email_param, ip_address_param, user_agent_param, reason_param
    );
  END IF;

  RETURN QUERY SELECT true, ''Configuration saved successfully'', new_config_id;
EXCEPTION
  WHEN OTHERS THEN
    RETURN QUERY SELECT false, SQLERRM, NULL::uuid;
END;
';

CREATE OR REPLACE FUNCTION delete_runtime_config(config_key text, env_name text, admin_id_param uuid, admin_email_param text, ip_address_param text, user_agent_param text, reason_param text) RETURNS TABLE(success boolean, message text) LANGUAGE plpgsql AS '
DECLARE
  existing_config runtime_config%ROWTYPE;
BEGIN
  -- Get existing config for audit log
  SELECT * INTO existing_config
  FROM runtime_config
  WHERE key = config_key AND environment = env_name;

  IF existing_config.id IS NULL THEN
    RETURN QUERY SELECT false, ''Configuration not found'';
    RETURN;
  END IF;

  -- Delete the config
  DELETE FROM runtime_config
  WHERE key = config_key AND environment = env_name;

  -- Log the deletion
  INSERT INTO config_audit_log (
    config_key, environment, action, old_value,
    admin_id, admin_email, ip_address, user_agent, reason
  ) VALUES (
    config_key, env_name, ''delete'', existing_config.value,
    admin_id_param, admin_email_param, ip_address_param, user_agent_param, reason_param
  );

  RETURN QUERY SELECT true, ''Configuration deleted successfully'';
EXCEPTION
  WHEN OTHERS THEN
    RETURN QUERY SELECT false, SQLERRM;
END;
';

CREATE OR REPLACE FUNCTION update_bug_report_updated_at() RETURNS trigger LANGUAGE plpgsql AS '
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
';

CREATE OR REPLACE FUNCTION assign_bug_report(p_bug_id text, p_assigned_to text) RETURNS TABLE(success boolean, message text) LANGUAGE plpgsql AS '
BEGIN
  -- Update bug report assignment
  UPDATE bug_reports 
  SET 
    assigned_to = p_assigned_to,
    updated_at = NOW()
  WHERE bug_id = p_bug_id;
  
  IF FOUND THEN
    RETURN QUERY SELECT true, ''Bug report assigned successfully'';
  ELSE
    RETURN QUERY SELECT false, ''Bug report not found'';
  END IF;
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN QUERY SELECT false, ''Failed to assign bug report: '' || SQLERRM;
END;
';

CREATE OR REPLACE FUNCTION insert_bug_report_from_mobile(p_title text, p_description text, p_priority text, p_category text, p_user_id uuid, p_user_email text, p_device_info jsonb, p_app_version text, p_issue_type text) RETURNS TABLE(bug_id text, success boolean, message text, estimated_response_time text) LANGUAGE plpgsql AS '
DECLARE
  v_bug_id TEXT;
  v_estimated_response_time TEXT;
BEGIN
  -- Generate unique bug ID
  v_bug_id := ''bug-'' || EXTRACT(EPOCH FROM NOW())::TEXT || ''-'' || substr(md5(random()::text), 1, 9);
  
  -- Determine estimated response time based on priority
  CASE p_priority
    WHEN ''critical'' THEN v_estimated_response_time := ''1 hour'';
    WHEN ''high'' THEN v_estimated_response_time := ''2-4 hours'';
    WHEN ''medium'' THEN v_estimated_response_time := ''4-8 hours'';
    WHEN ''low'' THEN v_estimated_response_time := ''24 hours'';
    ELSE v_estimated_response_time := ''4-8 hours'';
  END CASE;
  
  -- Insert bug report
  INSERT INTO bug_reports (
    bug_id,
    title,
    description,
    status,
    priority,
    category,
    reported_by,
    user_id,
    user_email,
    device_info,
    app_version,
    issue_type,
    source,
    estimated_response_time
  ) VALUES (
    v_bug_id,
    p_title,
    p_description,
    ''new'',
    p_priority,
    p_category,
    COALESCE(p_user_email, p_user_id::text, ''mobile_user''),
    p_user_id,
    p_user_email,
    p_device_info,
    p_app_version,
    p_issue_type,
    ''mobile_app'',
    v_estimated_response_time
  );
  
  -- Return success response
  RETURN QUERY SELECT 
    v_bug_id,
    true,
    ''Bug report submitted successfully'',
    v_estimated_response_time;
    
EXCEPTION
  WHEN OTHERS THEN
    -- Return error response
    RETURN QUERY SELECT 
      NULL::TEXT,
      false,
      ''Failed to submit bug report: '' || SQLERRM,
      NULL::TEXT;
END;
';

CREATE OR REPLACE FUNCTION update_bug_report_status(p_bug_id text, p_status text, p_admin_notes text, p_resolution_notes text) RETURNS TABLE(success boolean, message text) LANGUAGE plpgsql AS '
BEGIN
  -- Update bug report
  UPDATE bug_reports 
  SET 
    status = p_status,
    admin_notes = COALESCE(p_admin_notes, admin_notes),
    resolution_notes = COALESCE(p_resolution_notes, resolution_notes),
    updated_at = NOW()
  WHERE bug_id = p_bug_id;
  
  IF FOUND THEN
    RETURN QUERY SELECT true, ''Bug report status updated successfully'';
  ELSE
    RETURN QUERY SELECT false, ''Bug report not found'';
  END IF;
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN QUERY SELECT false, ''Failed to update bug report: '' || SQLERRM;
END;
';

CREATE OR REPLACE FUNCTION check_videos_table_permissions() RETURNS TABLE(permission_type text, is_allowed boolean, role_name text, additional_info text) LANGUAGE plpgsql AS '
BEGIN
  RETURN QUERY 
  SELECT 
    ''INSERT''::TEXT, 
    (SELECT COUNT(*) > 0 FROM information_schema.table_privileges 
     WHERE table_name = ''videos'' AND privilege_type = ''INSERT'' AND grantee = CURRENT_USER),
    CURRENT_USER,
    ''Ability to insert rows into videos table''
  UNION ALL
  SELECT 
    ''UPDATE''::TEXT, 
    (SELECT COUNT(*) > 0 FROM information_schema.table_privileges 
     WHERE table_name = ''videos'' AND privilege_type = ''UPDATE'' AND grantee = CURRENT_USER),
    CURRENT_USER,
    ''Ability to update rows in videos table''
  UNION ALL
  SELECT 
    ''RLS Enabled''::TEXT, 
    (SELECT relrowsecurity FROM pg_class WHERE relname = ''videos''),
    CURRENT_USER,
    ''Whether Row Level Security is enabled''
  UNION ALL
  SELECT 
    ''RLS Policies''::TEXT, 
    (SELECT COUNT(*) > 0 FROM pg_policies WHERE tablename = ''videos''),
    CURRENT_USER,
    ''Number of RLS policies on videos table''
  UNION ALL
  SELECT 
    ''Current Role Policies''::TEXT, 
    (SELECT COUNT(*) > 0 FROM pg_policies 
     WHERE tablename = ''videos'' AND roles @> ARRAY[CURRENT_USER]),
    CURRENT_USER,
    ''Policies applicable to current role'';
END;
';

CREATE OR REPLACE FUNCTION prevent_owner_metrics_update() RETURNS trigger LANGUAGE plpgsql AS '
BEGIN
  -- This trigger serves as an additional safety net
  -- It should never be needed if functions are called correctly
  -- but provides extra protection against accidental owner metric updates
  
  -- For any direct UPDATE attempts on videos table,
  -- log a warning if someone tries to update metrics inappropriately
  IF TG_OP = ''UPDATE'' THEN
    -- Log any suspicious metric updates (for debugging)
    IF OLD.views_count != NEW.views_count OR 
       OLD.total_watch_time != NEW.total_watch_time THEN
      -- This is just a safety net - normal operations should prevent this
      RAISE LOG ''Video metrics updated for video_id: %, views: % -> %, watch_time: % -> %'',
        NEW.id, OLD.views_count, NEW.views_count, OLD.total_watch_time, NEW.total_watch_time;
    END IF;
  END IF;
  
  RETURN NEW;
END;
';

CREATE OR REPLACE FUNCTION handle_new_user() RETURNS trigger LANGUAGE plpgsql AS '
DECLARE
  new_username TEXT;
BEGIN
  -- Generate a unique username
  new_username := COALESCE(
    NEW.raw_user_meta_data->>''username'', 
    ''user_'' || substr(NEW.id::text, 1, 8)
  );
  
  -- Ensure username is unique by appending a number if needed
  WHILE EXISTS (SELECT 1 FROM profiles WHERE username = new_username) LOOP
    new_username := COALESCE(NEW.raw_user_meta_data->>''username'', ''user'') || ''_'' || substr(NEW.id::text, 1, 8) || ''_'' || floor(random() * 1000)::text;
  END LOOP;
  
  -- Insert the profile with proper error handling
  INSERT INTO profiles (id, email, username, coins, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    new_username,
    100, -- Starting coins
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING; -- Prevent duplicate insertions
  
  RETURN NEW;
EXCEPTION
  WHEN others THEN
    -- Log the error but don''t fail the user creation
    RAISE WARNING ''Failed to create profile for user % (email: %): %'', NEW.id, NEW.email, SQLERRM;
    
    -- Try a simpler insert as fallback
    BEGIN
      INSERT INTO profiles (id, email, username)
      VALUES (
        NEW.id,
        COALESCE(NEW.email, ''user@example.com''),
        ''user_'' || substr(NEW.id::text, 1, 8) || ''_'' || extract(epoch from now())::bigint
      )
      ON CONFLICT (id) DO NOTHING;
    EXCEPTION
      WHEN others THEN
        RAISE WARNING ''Fallback profile creation also failed for user %: %'', NEW.id, SQLERRM;
    END;
    
    RETURN NEW;
END;
';

CREATE OR REPLACE FUNCTION check_and_update_expired_holds() RETURNS integer LANGUAGE plpgsql AS '
DECLARE
  updated_count INTEGER;
BEGIN
  -- Update videos from on_hold to active if hold_until has passed
  UPDATE videos 
  SET status = ''active'', updated_at = NOW()
  WHERE status = ''on_hold'' 
  AND hold_until <= NOW()
  AND completed = FALSE;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  
  RETURN updated_count;
END;
';

CREATE OR REPLACE FUNCTION log_admin_action(admin_id_param text, action_param text, target_type_param text, target_id_param uuid, old_values_param jsonb, new_values_param jsonb, ip_address_param text, user_agent_param text, details_param jsonb) RETURNS uuid LANGUAGE plpgsql AS '
DECLARE
  log_id UUID;
BEGIN
  INSERT INTO admin_logs (
    admin_id, action, target_type, target_id, old_values, new_values, 
    ip_address, user_agent, details
  ) VALUES (
    admin_id_param, action_param, target_type_param, target_id_param,
    old_values_param, new_values_param, ip_address_param, user_agent_param, details_param
  ) RETURNING id INTO log_id;
  
  RETURN log_id;
END;
';

CREATE OR REPLACE FUNCTION admin_adjust_user_coins(user_uuid uuid, coin_adjustment integer, reason text, admin_id text) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  user_record RECORD;
  new_balance INTEGER;
BEGIN
  SELECT * INTO user_record FROM profiles WHERE id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''User not found'');
  END IF;
  
  new_balance := user_record.coins + coin_adjustment;
  
  IF new_balance < 0 THEN
    RETURN json_build_object(''success'', false, ''error'', ''Insufficient coins for adjustment'');
  END IF;
  
  UPDATE profiles 
  SET coins = new_balance, updated_at = NOW()
  WHERE id = user_uuid;
  
  INSERT INTO coin_transactions (
    user_id, amount, transaction_type, description, reference_id
  ) VALUES (
    user_uuid, coin_adjustment, ''admin_adjustment'', reason, user_uuid
  );
  
  RETURN json_build_object(
    ''success'', true,
    ''new_balance'', new_balance,
    ''adjustment'', coin_adjustment,
    ''message'', ''User coins adjusted successfully''
  );
END;
';

CREATE OR REPLACE FUNCTION create_video_promotion(coin_cost_param integer, coin_reward_param integer, duration_seconds_param integer, target_views_param integer, title_param text, user_uuid uuid, youtube_url_param text) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  user_record RECORD;
  new_video_id UUID;
  new_balance INTEGER;
BEGIN
  -- Get user profile
  SELECT * INTO user_record FROM profiles WHERE id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''User not found'');
  END IF;
  
  -- Check if user has enough coins
  IF user_record.coins < coin_cost_param THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Insufficient coins'',
      ''required'', coin_cost_param,
      ''available'', user_record.coins
    );
  END IF;
  
  -- Deduct coins from user
  UPDATE profiles 
  SET coins = coins - coin_cost_param, updated_at = NOW()
  WHERE id = user_uuid
  RETURNING coins INTO new_balance;
  
  -- Create video record
  INSERT INTO videos (
    user_id,
    youtube_url,
    title,
    target_views,
    duration_seconds,
    coin_reward,
    coin_cost,
    status,
    hold_until,
    views_count,
    total_watch_time,
    completion_rate,
    completed,
    coins_earned_total
  ) VALUES (
    user_uuid,
    youtube_url_param,
    title_param,
    target_views_param,
    duration_seconds_param,
    coin_reward_param,
    coin_cost_param,
    ''on_hold'',
    NOW() + INTERVAL ''10 minutes'',
    0,  -- Start with 0 views
    0,  -- Start with 0 watch time
    0.0,  -- Start with 0% completion
    FALSE,  -- Not completed initially
    0   -- No coins earned yet
  ) RETURNING id INTO new_video_id;
  
  RETURN json_build_object(
    ''success'', true,
    ''video_id'', new_video_id,
    ''new_balance'', new_balance,
    ''message'', ''Video created successfully and will be active after 10-minute hold period''
  );
END;
';

CREATE OR REPLACE FUNCTION auto_update_video_status() RETURNS trigger LANGUAGE plpgsql AS '
BEGIN
  -- Auto-update completion status based on views vs target
  IF NEW.views_count >= NEW.target_views AND NEW.completed = FALSE THEN
    NEW.completed := TRUE;
    NEW.status := ''completed'';
  END IF;
  
  -- Auto-calculate completion rate
  IF NEW.target_views > 0 THEN
    NEW.completion_rate := LEAST(100.0, (NEW.views_count::decimal / NEW.target_views) * 100);
  ELSE
    NEW.completion_rate := 0.0;
  END IF;
  
  -- Update timestamp
  NEW.updated_at := NOW();
  
  RETURN NEW;
END;
';

CREATE OR REPLACE FUNCTION update_transactions_updated_at() RETURNS trigger LANGUAGE plpgsql AS '
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
';

CREATE OR REPLACE FUNCTION delete_video_with_refund(video_uuid uuid, user_uuid uuid) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
  minutes_since_creation INTEGER;
  refund_percentage INTEGER;
  refund_amount INTEGER;
  new_balance INTEGER;
BEGIN
  -- Get video details
  SELECT * INTO video_record FROM videos WHERE id = video_uuid AND user_id = user_uuid;
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''Video not found or not owned by user'');
  END IF;

  -- Calculate minutes since creation
  minutes_since_creation := EXTRACT(EPOCH FROM (NOW() - video_record.created_at)) / 60;

  -- Determine refund percentage
  IF minutes_since_creation <= 10 THEN
    refund_percentage := 100;
  ELSE
    refund_percentage := 80;
  END IF;

  refund_amount := (video_record.coin_cost * refund_percentage) / 100;

  -- Update user balance
  UPDATE profiles 
  SET coins = coins + refund_amount, updated_at = NOW() 
  WHERE id = user_uuid 
  RETURNING coins INTO new_balance;

  -- Record deletion for Recent Activity tracking
  INSERT INTO video_deletions (
    video_id, user_id, video_title, coin_cost, refund_amount, refund_percentage
  ) VALUES (
    video_uuid, user_uuid, video_record.title, video_record.coin_cost, refund_amount, refund_percentage
  );

  -- Completely delete the video row (no status change)
  DELETE FROM videos WHERE id = video_uuid;

  RETURN json_build_object(
    ''success'', true,
    ''refund_amount'', refund_amount,
    ''refund_percentage'', refund_percentage,
    ''new_balance'', new_balance,
    ''message'', ''Video deleted successfully with '' || refund_percentage || ''% refund''
  );
END;
';

CREATE OR REPLACE FUNCTION admin_update_user_vip_status(user_uuid uuid, is_vip boolean, vip_duration_days integer, admin_id text) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  user_record RECORD;
BEGIN
  SELECT * INTO user_record FROM profiles WHERE id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''User not found'');
  END IF;
  
  UPDATE profiles 
  SET 
    is_vip = is_vip,
    vip_expires_at = CASE 
      WHEN is_vip THEN NOW() + INTERVAL ''1 day'' * vip_duration_days
      ELSE NULL
    END,
    updated_at = NOW()
  WHERE id = user_uuid;
  
  RETURN json_build_object(
    ''success'', true,
    ''is_vip'', is_vip,
    ''vip_expires_at'', CASE 
      WHEN is_vip THEN NOW() + INTERVAL ''1 day'' * vip_duration_days
      ELSE NULL
    END,
    ''message'', ''User VIP status updated successfully''
  );
END;
';

CREATE OR REPLACE FUNCTION validate_video_watch_permission(user_uuid uuid, video_uuid uuid) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
BEGIN
  -- Get video details
  SELECT * INTO video_record FROM videos WHERE id = video_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      ''allowed'', false, 
      ''error'', ''Video not found'',
      ''code'', ''VIDEO_NOT_FOUND''
    );
  END IF;
  
  -- Check if user is the video owner
  IF video_record.user_id = user_uuid THEN
    RETURN json_build_object(
      ''allowed'', false, 
      ''error'', ''Video owners cannot watch their own videos'',
      ''code'', ''OWNER_RESTRICTION'',
      ''video_owner'', true
    );
  END IF;
  
  -- Check if video is completed
  IF video_record.completed = TRUE THEN
    RETURN json_build_object(
      ''allowed'', false, 
      ''error'', ''Video has reached target views and is completed'',
      ''code'', ''VIDEO_COMPLETED'',
      ''video_completed'', true
    );
  END IF;
  
  -- Check video status
  IF video_record.status NOT IN (''active'', ''repromoted'') AND 
     NOT (video_record.status = ''on_hold'' AND video_record.hold_until <= NOW()) THEN
    RETURN json_build_object(
      ''allowed'', false, 
      ''error'', ''Video is not available for watching'',
      ''code'', ''VIDEO_NOT_AVAILABLE'',
      ''video_status'', video_record.status
    );
  END IF;
  
  -- All checks passed
  RETURN json_build_object(
    ''allowed'', true,
    ''video_id'', video_record.id,
    ''video_title'', video_record.title,
    ''coin_reward'', video_record.coin_reward,
    ''duration_seconds'', video_record.duration_seconds,
    ''views_count'', video_record.views_count,
    ''target_views'', video_record.target_views,
    ''video_owner'', false
  );
END;
';

CREATE OR REPLACE FUNCTION admin_update_video_status(video_uuid uuid, new_status text, admin_id text, reason text) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
BEGIN
  SELECT * INTO video_record FROM videos WHERE id = video_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''Video not found'');
  END IF;
  
  IF new_status NOT IN (''active'', ''paused'', ''completed'', ''on_hold'', ''repromoted'') THEN
    RETURN json_build_object(''success'', false, ''error'', ''Invalid status'');
  END IF;
  
  UPDATE videos 
  SET 
    status = new_status,
    updated_at = NOW(),
    hold_until = CASE WHEN new_status = ''on_hold'' THEN NOW() + INTERVAL ''10 minutes'' ELSE hold_until END,
    repromoted_at = CASE WHEN new_status = ''repromoted'' THEN NOW() ELSE repromoted_at END
  WHERE id = video_uuid;
  
  INSERT INTO coin_transactions (
    user_id, amount, transaction_type, description, reference_id
  ) VALUES (
    video_record.user_id, 0, ''admin_adjustment'', 
    ''Video status changed to '' || new_status || CASE WHEN reason IS NOT NULL THEN '': '' || reason ELSE '''' END,
    video_uuid
  );
  
  RETURN json_build_object(
    ''success'', true,
    ''new_status'', new_status,
    ''message'', ''Video status updated successfully''
  );
END;
';

CREATE OR REPLACE FUNCTION check_promotion_queue_eligibility(video_uuid uuid) RETURNS boolean LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
BEGIN
  -- Get video details
  SELECT views_count, target_views, status, hold_until
  INTO video_record
  FROM videos 
  WHERE id = video_uuid;
  
  -- Return false if video doesn''t exist
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Check if video has reached target views
  IF video_record.views_count >= video_record.target_views THEN
    -- Update video status to completed if it reached target
    UPDATE videos 
    SET status = ''completed'', updated_at = NOW()
    WHERE id = video_uuid AND status IN (''active'', ''repromoted'', ''on_hold'');
    
    RETURN FALSE; -- Remove from promotion queue
  END IF;
  
  -- Video is eligible if it''s active, repromoted, or on_hold with expired hold_until
  RETURN video_record.status IN (''active'', ''repromoted'') OR 
         (video_record.status = ''on_hold'' AND video_record.hold_until <= NOW());
END;
';

CREATE OR REPLACE FUNCTION check_and_loop_video_queue(user_uuid uuid) RETURNS boolean LANGUAGE plpgsql AS '
DECLARE
  available_videos INTEGER;
BEGIN
  -- Check if there are any available videos for the user
  SELECT COUNT(*) INTO available_videos
  FROM videos v
  WHERE (
    v.status IN (''active'', ''repromoted'') OR 
    (v.status = ''on_hold'' AND v.hold_until <= NOW())
  )
  AND v.user_id != user_uuid
  AND v.completed = FALSE;
  
  -- If no videos available, this means all videos have been watched
  -- The queue will automatically loop because we removed the "already watched" restriction
  
  RETURN (available_videos > 0);
END;
';

CREATE OR REPLACE FUNCTION watch_video_and_earn_coins(p_video_uuid uuid, p_watch_duration integer, p_video_fully_watched boolean) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  v_video_record RECORD;
  v_current_user_uuid UUID;
  v_coins_to_award INTEGER;
  v_new_user_balance INTEGER;
  v_is_complete_watch BOOLEAN;
  v_new_total_watch_time INTEGER;
  v_new_completion_rate DECIMAL(5,2);
BEGIN
  -- Get current user
  v_current_user_uuid := auth.uid();

  -- Validate input parameters
  IF v_current_user_uuid IS NULL OR p_video_uuid IS NULL THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Invalid authentication or video UUID''
    );
  END IF;

  -- Fetch video details WITHOUT filtering out the owner
  SELECT * INTO v_video_record 
  FROM videos v
  WHERE 
    v.id = p_video_uuid AND
    v.completed = FALSE AND 
    v.status = ''active'';
  
  -- Check if video exists and meets criteria
  IF v_video_record IS NULL THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Video not available for watching''
    );
  END IF;

  -- Prevent video owner from watching their own video
  IF v_video_record.user_id = v_current_user_uuid THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Cannot watch your own video''
    );
  END IF;

  -- Calculate coins based on watch duration
  v_is_complete_watch := (p_watch_duration >= v_video_record.duration_seconds) OR p_video_fully_watched;
  
  v_coins_to_award := CASE 
    WHEN v_is_complete_watch THEN v_video_record.coin_reward
    ELSE GREATEST(1, (v_video_record.coin_reward * p_watch_duration / v_video_record.duration_seconds))
  END;

  -- Update user balance
  UPDATE profiles 
  SET 
    coins = coins + v_coins_to_award, 
    updated_at = NOW()
  WHERE id = v_current_user_uuid
  RETURNING coins INTO v_new_user_balance;

  -- Calculate new video metrics
  v_new_total_watch_time := v_video_record.total_watch_time + p_watch_duration;

  -- Calculate completion rate
  v_new_completion_rate := CASE 
    WHEN v_video_record.target_views > 0 THEN 
      LEAST(100.0, ((v_video_record.views_count + 1)::decimal / v_video_record.target_views) * 100)
    ELSE 0.0
  END;

  -- Update video metrics for non-owner users
  UPDATE videos 
  SET 
    views_count = views_count + 1,
    total_watch_time = total_watch_time + p_watch_duration,
    completion_rate = v_new_completion_rate,
    coins_earned_total = coins_earned_total + v_coins_to_award,
    completed = CASE 
      WHEN (views_count + 1) >= target_views THEN TRUE 
      ELSE FALSE 
    END,
    status = CASE 
      WHEN (views_count + 1) >= target_views THEN ''completed''
      ELSE status
    END,
    updated_at = NOW()
  WHERE id = p_video_uuid;

  -- Return comprehensive response
  RETURN json_build_object(
    ''success'', true,
    ''coins_awarded'', v_coins_to_award,
    ''new_user_balance'', v_new_user_balance,
    ''video_views_count'', v_video_record.views_count + 1,
    ''video_total_watch_time'', v_new_total_watch_time,
    ''video_completion_rate'', v_new_completion_rate
  );
END;
';

CREATE OR REPLACE FUNCTION check_admin_permission(admin_email text, required_permission text) RETURNS boolean LANGUAGE plpgsql AS '
DECLARE
  admin_record RECORD;
BEGIN
  SELECT * INTO admin_record 
  FROM admin_profiles 
  WHERE email = admin_email AND is_active = true;
  
  IF NOT FOUND THEN
    RETURN false;
  END IF;
  
  IF admin_record.role = ''super_admin'' THEN
    RETURN true;
  END IF;
  
  RETURN (admin_record.permissions->>required_permission)::BOOLEAN = true;
END;
';

CREATE OR REPLACE FUNCTION create_missing_profile(user_id uuid, user_email text, user_username text) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  final_username TEXT;
  profile_exists BOOLEAN;
BEGIN
  -- Check if profile already exists
  SELECT EXISTS(SELECT 1 FROM profiles WHERE id = user_id) INTO profile_exists;
  
  IF profile_exists THEN
    RETURN json_build_object(
      ''success'', true,
      ''message'', ''Profile already exists'',
      ''action'', ''none''
    );
  END IF;
  
  -- Generate username
  final_username := COALESCE(
    user_username,
    ''user_'' || substr(user_id::text, 1, 8)
  );
  
  -- Ensure username is unique
  WHILE EXISTS (SELECT 1 FROM profiles WHERE username = final_username) LOOP
    final_username := COALESCE(user_username, ''user'') || ''_'' || substr(user_id::text, 1, 8) || ''_'' || floor(random() * 1000)::text;
  END LOOP;
  
  -- Create the profile
  INSERT INTO profiles (id, email, username, coins, created_at, updated_at)
  VALUES (
    user_id,
    user_email,
    final_username,
    100,
    NOW(),
    NOW()
  );
  
  RETURN json_build_object(
    ''success'', true,
    ''message'', ''Profile created successfully'',
    ''username'', final_username,
    ''action'', ''created''
  );
  
EXCEPTION
  WHEN others THEN
    RETURN json_build_object(
      ''success'', false,
      ''error'', SQLERRM,
      ''action'', ''failed''
    );
END;
';

CREATE OR REPLACE FUNCTION watch_video_and_earn_coins(user_uuid uuid, video_uuid uuid, watch_duration integer, video_fully_watched boolean) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
  user_record RECORD;
  coins_to_award INTEGER;
  new_user_balance INTEGER;
  is_complete_watch BOOLEAN;
  new_total_watch_time INTEGER;
  new_completion_rate DECIMAL(5,2);
  rows_affected INTEGER;
BEGIN
  -- Get video details
  SELECT * INTO video_record FROM videos WHERE id = video_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''Video not found'');
  END IF;
  
  -- STRICT OWNER RESTRICTION: Prevent video owners from watching their own videos
  IF video_record.user_id = user_uuid THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Video owners cannot watch their own videos'',
      ''code'', ''OWNER_RESTRICTION''
    );
  END IF;
  
  -- Check if video is completed (reached target views)
  IF video_record.completed = TRUE THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Video has reached target views and is completed'',
      ''code'', ''VIDEO_COMPLETED''
    );
  END IF;
  
  -- Get user profile
  SELECT * INTO user_record FROM profiles WHERE id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''User not found'');
  END IF;
  
  -- Determine if this is a complete watch
  is_complete_watch := (watch_duration >= video_record.duration_seconds) OR video_fully_watched;
  
  -- Calculate coins to award
  IF is_complete_watch THEN
    coins_to_award := video_record.coin_reward;
  ELSE
    -- Partial reward based on watch percentage
    coins_to_award := GREATEST(1, (video_record.coin_reward * watch_duration / video_record.duration_seconds));
  END IF;
  
  -- Update user balance directly
  UPDATE profiles 
  SET coins = coins + coins_to_award, updated_at = NOW()
  WHERE id = user_uuid
  RETURNING coins INTO new_user_balance;
  
  -- Calculate new metrics
  new_total_watch_time := video_record.total_watch_time + watch_duration;
  new_completion_rate := CASE 
    WHEN video_record.target_views > 0 THEN 
      LEAST(100.0, ((video_record.views_count + 1)::decimal / video_record.target_views) * 100)
    ELSE 0.0
  END;
  
  -- UPDATE VIDEO METRICS: This should work for non-owner viewers
  -- Since we already checked that user_uuid != video_record.user_id above,
  -- we can safely update the video metrics
  UPDATE videos 
  SET 
    views_count = views_count + 1,
    total_watch_time = new_total_watch_time,
    completion_rate = new_completion_rate,
    coins_earned_total = coins_earned_total + coins_to_award,
    completed = CASE 
      WHEN (views_count + 1) >= target_views THEN TRUE 
      ELSE FALSE 
    END,
    status = CASE 
      WHEN (views_count + 1) >= target_views THEN ''completed''
      ELSE status
    END,
    updated_at = NOW()
  WHERE id = video_uuid;
  
  -- Get the number of rows affected by the update
  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  
  -- Get updated video data to return accurate information
  SELECT * INTO video_record FROM videos WHERE id = video_uuid;
  
  RETURN json_build_object(
    ''success'', true,
    ''coins_awarded'', coins_to_award,
    ''new_user_balance'', new_user_balance,
    ''video_views_count'', video_record.views_count,
    ''video_total_watch_time'', video_record.total_watch_time,
    ''video_completion_rate'', video_record.completion_rate,
    ''video_completed'', video_record.completed,
    ''watch_duration'', watch_duration,
    ''is_complete_watch'', is_complete_watch,
    ''viewer_type'', ''external'',
    ''metrics_updated'', (rows_affected > 0),
    ''video_status'', video_record.status
  );
END;
';

CREATE OR REPLACE FUNCTION debug_watch_video(user_uuid uuid, video_uuid uuid, watch_duration integer) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_before RECORD;
  video_after RECORD;
  user_before RECORD;
  user_after RECORD;
  watch_result JSON;
BEGIN
  -- Get initial states
  SELECT * INTO video_before FROM videos WHERE id = video_uuid;
  SELECT * INTO user_before FROM profiles WHERE id = user_uuid;
  
  -- Attempt to watch video
  SELECT watch_video_and_earn_coins(user_uuid, video_uuid, watch_duration, true) INTO watch_result;
  
  -- Get final states
  SELECT * INTO video_after FROM videos WHERE id = video_uuid;
  SELECT * INTO user_after FROM profiles WHERE id = user_uuid;
  
  RETURN json_build_object(
    ''watch_result'', watch_result,
    ''video_before'', json_build_object(
      ''views_count'', video_before.views_count,
      ''total_watch_time'', video_before.total_watch_time,
      ''completion_rate'', video_before.completion_rate,
      ''owner_id'', video_before.user_id
    ),
    ''video_after'', json_build_object(
      ''views_count'', video_after.views_count,
      ''total_watch_time'', video_after.total_watch_time,
      ''completion_rate'', video_after.completion_rate,
      ''owner_id'', video_after.user_id
    ),
    ''user_before'', json_build_object(
      ''coins'', user_before.coins
    ),
    ''user_after'', json_build_object(
      ''coins'', user_after.coins
    ),
    ''is_owner'', (video_before.user_id = user_uuid),
    ''changes'', json_build_object(
      ''views_changed'', (video_after.views_count != video_before.views_count),
      ''watch_time_changed'', (video_after.total_watch_time != video_before.total_watch_time),
      ''coins_changed'', (user_after.coins != user_before.coins)
    )
  );
END;
';

CREATE OR REPLACE FUNCTION test_metrics_update(video_uuid uuid, increment_views integer, add_watch_time integer) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_before RECORD;
  video_after RECORD;
  rows_affected INTEGER;
BEGIN
  -- Get video state before
  SELECT * INTO video_before FROM videos WHERE id = video_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''error'', ''Video not found'');
  END IF;
  
  -- Attempt direct update
  UPDATE videos 
  SET 
    views_count = views_count + increment_views,
    total_watch_time = total_watch_time + add_watch_time,
    updated_at = NOW()
  WHERE id = video_uuid;
  
  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  
  -- Get video state after
  SELECT * INTO video_after FROM videos WHERE id = video_uuid;
  
  RETURN json_build_object(
    ''rows_affected'', rows_affected,
    ''before'', json_build_object(
      ''views_count'', video_before.views_count,
      ''total_watch_time'', video_before.total_watch_time
    ),
    ''after'', json_build_object(
      ''views_count'', video_after.views_count,
      ''total_watch_time'', video_after.total_watch_time
    ),
    ''changes_applied'', json_build_object(
      ''views_increment'', increment_views,
      ''watch_time_increment'', add_watch_time
    )
  );
END;
';

CREATE OR REPLACE FUNCTION repromote_video(video_uuid uuid, user_uuid uuid, additional_coin_cost integer) RETURNS json LANGUAGE plpgsql AS '
DECLARE
  video_record RECORD;
  user_record RECORD;
  new_user_balance INTEGER;
BEGIN
  -- Get video details
  SELECT * INTO video_record FROM videos WHERE id = video_uuid AND user_id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''Video not found or not owned by user'');
  END IF;
  
  -- Check if video is completed (can only repromote completed videos)
  IF video_record.completed = FALSE THEN
    RETURN json_build_object(''success'', false, ''error'', ''Video is not completed yet, cannot repromote'');
  END IF;
  
  -- Get user profile
  SELECT * INTO user_record FROM profiles WHERE id = user_uuid;
  
  IF NOT FOUND THEN
    RETURN json_build_object(''success'', false, ''error'', ''User not found'');
  END IF;
  
  -- Check if user has enough coins for additional cost
  IF additional_coin_cost > 0 AND user_record.coins < additional_coin_cost THEN
    RETURN json_build_object(
      ''success'', false, 
      ''error'', ''Insufficient coins for repromoting'',
      ''required'', additional_coin_cost,
      ''available'', user_record.coins
    );
  END IF;
  
  -- Deduct additional coins if any
  IF additional_coin_cost > 0 THEN
    UPDATE profiles 
    SET coins = coins - additional_coin_cost, updated_at = NOW()
    WHERE id = user_uuid
    RETURNING coins INTO new_user_balance;
  ELSE
    new_user_balance := user_record.coins;
  END IF;
  
  -- Reset video for repromotion (views_count to 0, keep total_watch_time)
  UPDATE videos 
  SET 
    views_count = 0,  -- Reset views to start counting from 0
    -- total_watch_time stays the same (accumulative)
    completion_rate = 0.0,  -- Reset completion rate
    completed = FALSE,  -- Reset completed status
    status = ''active'',  -- Set status to active
    repromoted_at = NOW(),  -- Update repromoted timestamp
    updated_at = NOW()
  WHERE id = video_uuid;
  
  RETURN json_build_object(
    ''success'', true,
    ''message'', ''Video repromoted successfully'',
    ''new_user_balance'', new_user_balance,
    ''additional_cost'', additional_coin_cost,
    ''video_id'', video_uuid,
    ''repromoted_at'', NOW(),
    ''views_count_reset_to'', 0,
    ''total_watch_time_preserved'', video_record.total_watch_time
  );
END;
';


-- Commit Transaction
COMMIT;

-- Backup completed successfully
-- Total tables: 8
-- Generated at: 2025-08-10T17:44:05.799Z
-- Database: https://kuibswqfmhhdybttbcoa.supabase.co
-- This backup includes: Tables, Data, Indexes, Triggers, RLS Policies, and Functions
